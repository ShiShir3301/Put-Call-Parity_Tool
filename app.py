# -*- coding: utf-8 -*-
"""app

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kHvMjZe07w3rYzmFZnVzczJiwo69leg6
"""

import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import streamlit as st
import requests
import pandas as pd

# Function to calculate values based on Put-Call Parity
def put_call_parity(S, K, r, T, C=None, P=None):
    present_value_of_strike = K * np.exp(-r * T)
    if C is None and P is not None:
        # Calculate Call value using Put-Call Parity
        C = P + S - present_value_of_strike
    elif P is None and C is not None:
        # Calculate Put value using Put-Call Parity
        P = C - S + present_value_of_strike
    elif C is None and P is None:
        raise ValueError("At least one of C (Call price) or P (Put price) must be provided.")
    return C, P, present_value_of_strike

def identify_arbitrage(S, K, r, T, C, P):
    """
    Identifies and explains arbitrage opportunities based on the put-call parity principle.

    Parameters:
    - S: Current stock price
    - K: Strike price
    - r: Risk-free interest rate
    - T: Time to maturity (in years)
    - C: Call option price
    - P: Put option price

    Returns:
    - Detailed explanation of the arbitrage strategy or a message indicating no arbitrage.
    """
    # Calculate the present value of the strike price and parity price
    _, _, pv_strike = put_call_parity(S, K, r, T, C, P)
    parity_price = P + S - pv_strike

    # Determine arbitrage opportunities
    if C > parity_price:
        return (
            f"Arbitrage Opportunity Detected (Overpriced Call):\n"
            f"Call Price (C): {C:.2f} > Parity Price: {parity_price:.2f}\n"
            f"Strategy:\n"
            f"1. Short the call option (Sell the call at {C:.2f}).\n"
            f"2. Buy the put option (Buy the put at {P:.2f}).\n"
            f"3. Buy the underlying asset (Stock price: {S:.2f}).\n"
            f"4. Borrow the present value of the strike price (PV(K): {pv_strike:.2f}) at the risk-free rate ({r:.2%}).\n"
            f"Outcome:\n"
            f"- Arbitrage profit locked in due to the mispricing of the call option.\n"
            f"- This is a 'reverse arbitrage' strategy where you exploit the overpriced call."
        )
    elif C < parity_price:
        return (
            f"Arbitrage Opportunity Detected (Underpriced Call):\n"
            f"Call Price (C): {C:.2f} < Parity Price: {parity_price:.2f}\n"
            f"Strategy:\n"
            f"1. Buy the call option (Buy the call at {C:.2f}).\n"
            f"2. Short the put option (Sell the put at {P:.2f}).\n"
            f"3. Short the underlying asset (Stock price: {S:.2f}).\n"
            f"4. Invest the present value of the strike price (PV(K): {pv_strike:.2f}) at the risk-free rate ({r:.2%}).\n"
            f"Outcome:\n"
            f"- Arbitrage profit locked in due to the mispricing of the call option.\n"
            f"- This is a 'classic arbitrage' strategy where you exploit the underpriced call."
        )
    elif P > parity_price:
        return (
            f"Arbitrage Opportunity Detected (Overpriced Put):\n"
            f"Put Price (P): {P:.2f} > Parity Price: {parity_price:.2f}\n"
            f"Strategy:\n"
            f"1. Short the put option (Sell the put at {P:.2f}).\n"
            f"2. Buy the call option (Buy the call at {C:.2f}).\n"
            f"3. Buy the underlying asset (Stock price: {S:.2f}).\n"
            f"4. Borrow the present value of the strike price (PV(K): {pv_strike:.2f}) at the risk-free rate ({r:.2%}).\n"
            f"Outcome:\n"
            f"- Arbitrage profit locked in due to the mispricing of the put option.\n"
            f"- This strategy takes advantage of an overpriced put."
        )
    elif P < parity_price:
        return (
            f"Arbitrage Opportunity Detected (Underpriced Put):\n"
            f"Put Price (P): {P:.2f} < Parity Price: {parity_price:.2f}\n"
            f"Strategy:\n"
            f"1. Buy the put option (Buy the put at {P:.2f}).\n"
            f"2. Short the call option (Sell the call at {C:.2f}).\n"
            f"3. Short the underlying asset (Stock price: {S:.2f}).\n"
            f"4. Invest the present value of the strike price (PV(K): {pv_strike:.2f}) at the risk-free rate ({r:.2%}).\n"
            f"Outcome:\n"
            f"- Arbitrage profit locked in due to the mispricing of the put option.\n"
            f"- This is a 'reverse arbitrage' strategy where you exploit the underpriced put."
        )
    else:
        return (
            f"No Arbitrage Opportunity:\n"
            f"Call Price (C): {C:.2f} matches Parity Price: {parity_price:.2f}\n"
            f"Put Price (P): {P:.2f} matches Parity Price: {parity_price:.2f}\n"
            f"The market prices are consistent with the put-call parity principle."
        )

# Function to fetch live stock price from Tiingo API
def fetch_live_price(ticker, token):
    url = f"https://api.tiingo.com/tiingo/daily/{ticker}/prices?token={token}"
    response = requests.get(url)
    if response.status_code == 200:
        data = response.json()
        return data[0]['close']
    else:
        raise ValueError(f"Failed to fetch data for ticker {ticker}. Check the ticker and token.")

# Function to fetch historical data and calculate volatility
def fetch_volatility(ticker, token, N):
    url = f"https://api.tiingo.com/tiingo/daily/{ticker}/prices?token={token}&startDate=2023-01-01"
    response = requests.get(url)
    if response.status_code == 200:
        data = response.json()
        df = pd.DataFrame(data)
        df['date'] = pd.to_datetime(df['date'])
        df.set_index('date', inplace=True)
        
        # Calculate daily returns
        df['return'] = df['adjClose'].pct_change()
        df = df.dropna()  # Drop the first NaN value due to pct_change()

        # Calculate the rolling volatility (standard deviation of returns)
        volatility = df['return'].rolling(window=N).std() * np.sqrt(252)  # Annualized volatility
        return volatility[-1]  # Return the most recent volatility value
    else:
        raise ValueError(f"Failed to fetch data for ticker {ticker}. Check the ticker and token.")

# Streamlit App
def main():
    st.title("Put-Call Parity and Arbitrage Tool")

    # Sidebar for user inputs
    S = st.sidebar.number_input('S (Stock Price)', value=100)
    K = st.sidebar.number_input('K (Strike Price)', value=100)
    r = st.sidebar.slider('r (Interest Rate)', min_value=0.0, max_value=0.2, value=0.05, step=0.005)
    T = st.sidebar.slider('T (Time to Expiry)', min_value=0.1, max_value=5.0, value=1.0, step=0.1)
    C = st.sidebar.number_input('C (Call Price)', value=0.0)
    P = st.sidebar.number_input('P (Put Price)', value=0.0)

    ticker = st.sidebar.text_input('Ticker (Optional)')
    live_price = st.sidebar.checkbox('Use Live Price')

    # If live price is checked and ticker is provided, fetch live stock price
    if live_price and ticker:
        try:
            S = fetch_live_price(ticker, "c8014c8227333b4647ff04d4378724f7345f3d4c")
            st.write(f"Live Stock Price for {ticker.upper()}: {S:.2f}")
        except ValueError as e:
            st.error(str(e))

    try:
        # Compute Call and Put values
        computed_C, computed_P, pv_strike = put_call_parity(S, K, r, T, C, P)
        st.write(f"Calculated Call Price: {computed_C:.2f}")
        st.write(f"Calculated Put Price: {computed_P:.2f}")
        st.write(f"Present Value of Strike (PV(K)): {pv_strike:.2f}")

        # Identify and display arbitrage opportunities
        arbitrage_message = identify_arbitrage(S, K, r, T, computed_C, computed_P)
        st.write(arbitrage_message)

        # Fetch Volatility if N is provided
        N = st.sidebar.number_input('N (Days for Volatility Calculation)', value=30, min_value=1, max_value=365)
        if ticker:
            volatility = fetch_volatility(ticker, "c8014c8227333b4647ff04d4378724f7345f3d4c", N)
            st.write(f"Volatility (last {N} days): {volatility:.2%}")

    except Exception as e:
        st.error(str(e))

if __name__ == "__main__":
    main()
