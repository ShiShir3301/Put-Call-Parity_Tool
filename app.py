# -*- coding: utf-8 -*-
"""app

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kHvMjZe07w3rYzmFZnVzczJiwo69leg6
"""

pip install streamlit numpy matplotlib seaborn requests

import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import streamlit as st
import requests

# Function to calculate values based on Put-Call Parity
def put_call_parity(S, K, r, T, C=None, P=None):
    present_value_of_strike = K * np.exp(-r * T)
    if C is None and P is not None:
        # Calculate Call value using Put-Call Parity
        C = P + S - present_value_of_strike
    elif P is None and C is not None:
        # Calculate Put value using Put-Call Parity
        P = C - S + present_value_of_strike
    elif C is None and P is None:
        raise ValueError("At least one of C (Call price) or P (Put price) must be provided.")
    return C, P, present_value_of_strike

# Function to identify arbitrage opportunities
def identify_arbitrage(S, K, r, T, C, P):
    _, _, pv_strike = put_call_parity(S, K, r, T, C, P)
    parity_price = P + S - pv_strike
    if C > parity_price:
        return f"Arbitrage Opportunity Detected (Overpriced Call): Call Price (C): {C:.2f} > Parity Price: {parity_price:.2f}"
    elif C < parity_price:
        return f"Arbitrage Opportunity Detected (Underpriced Call): Call Price (C): {C:.2f} < Parity Price: {parity_price:.2f}"
    else:
        return f"No Arbitrage Opportunity: Call Price (C): {C:.2f} matches Parity Price: {parity_price:.2f}"

# Function to fetch live stock price from Tiingo API
def fetch_live_price(ticker, token):
    url = f"https://api.tiingo.com/tiingo/daily/{ticker}/prices?token={token}"
    response = requests.get(url)
    if response.status_code == 200:
        data = response.json()
        return data[0]['close']
    else:
        raise ValueError(f"Failed to fetch data for ticker {ticker}. Check the ticker and token.")

# Function to plot profit/loss
def plot_profit(S, K, r, T, C, P):
    stock_prices = np.linspace(0.5 * K, 1.5 * K, 500)
    call_payoff = np.maximum(stock_prices - K, 0) - C
    put_payoff = np.maximum(K - stock_prices, 0) - P
    combined_payoff = call_payoff + put_payoff + stock_prices - K * np.exp(-r * T)

    plt.figure(figsize=(5, 3))
    plt.plot(stock_prices, call_payoff, label="Call Payoff", linestyle="--")
    plt.plot(stock_prices, put_payoff, label="Put Payoff", linestyle="--")
    plt.plot(stock_prices, combined_payoff, label="Arbitrage Payoff", linewidth=2)
    plt.axhline(0, color='black', linestyle='--', linewidth=0.8)
    plt.title("Profit/Loss Visualization")
    plt.xlabel("Stock Price at Expiration")
    plt.ylabel("Profit/Loss")
    plt.legend()
    plt.grid(True)
    st.pyplot(plt)

# Function to create a volatility heatmap
def plot_volatility_heatmap(K_values, T_values, volatility_matrix):
    plt.figure(figsize=(4, 4))
    sns.heatmap(volatility_matrix, annot=True, fmt=".2f", xticklabels=T_values, yticklabels=K_values, cmap="coolwarm")
    plt.title("Volatility Heatmap")
    plt.xlabel("Time to Expiry (T)")
    plt.ylabel("Strike Price (K)")
    st.pyplot(plt)

# Streamlit App
def main():
    st.title("Put-Call Parity and Arbitrage Tool")

    # Sidebar for user inputs
    S = st.sidebar.number_input('S (Stock Price)', value=100)
    K = st.sidebar.number_input('K (Strike Price)', value=100)
    r = st.sidebar.slider('r (Interest Rate)', min_value=0.0, max_value=0.2, value=0.05, step=0.005)
    T = st.sidebar.slider('T (Time to Expiry)', min_value=0.1, max_value=5.0, value=1.0, step=0.1)
    C = st.sidebar.number_input('C (Call Price)', value=0.0)
    P = st.sidebar.number_input('P (Put Price)', value=0.0)

    ticker = st.sidebar.text_input('Ticker (Optional)')
    live_price = st.sidebar.checkbox('Use Live Price')

    # If live price is checked and ticker is provided, fetch live stock price
    if live_price and ticker:
        try:
            S = fetch_live_price(ticker, "c8014c8227333b4647ff04d4378724f7345f3d4c")
            st.write(f"Live Stock Price for {ticker.upper()}: {S:.2f}")
        except ValueError as e:
            st.error(str(e))

    try:
        # Compute Call and Put values
        computed_C, computed_P, pv_strike = put_call_parity(S, K, r, T, C if C != 0 else None, P if P != 0 else None)

        # Display results
        st.subheader("Computed Values:")
        st.write(f"Call Price (C): {computed_C:.2f}")
        st.write(f"Put Price (P): {computed_P:.2f}")
        st.write(f"Present Value of Strike Price (K * e^(-rT)): {pv_strike:.2f}")

        # Identify Arbitrage
        st.subheader("Arbitrage Analysis:")
        st.write(identify_arbitrage(S, K, r, T, C if C != 0 else computed_C, P if P != 0 else computed_P))

        # Plot Profit/Loss
        plot_profit(S, K, r, T, C if C != 0 else computed_C, P if P != 0 else computed_P)

        # Example Volatility Heatmap (using synthetic data for demonstration)
        K_values = np.linspace(80, 120, 5)
        T_values = np.linspace(0.5, 2, 5)
        volatility_matrix = np.random.rand(5, 5) * 0.5  # Synthetic volatility data
        plot_volatility_heatmap(K_values, T_values, volatility_matrix)

    except ValueError as e:
        st.error(f"Error: {e}")

if __name__ == "__main__":
    main()